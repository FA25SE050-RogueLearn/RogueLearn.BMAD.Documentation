@startuml
actor Student
participant QuestManagementUI as UI
participant ":UsersController" as Controller
participant ":IMediator" as Med
participant ":GenerateQuestLine\nCommandHandler" as Handler
participant ":IUserProfileRepository" as IProfileRepo
participant ":UserProfileRepository" as ProfileRepo
participant ":ISubjectRepository" as ISubjectRepo
participant ":SubjectRepository" as SubjectRepo
participant ":IStudentSemesterSubject\nRepository" as IGradeRepo
participant ":StudentSemesterSubject\nRepository" as GradeRepo
participant ":IQuestRepository" as IQuestRepo
participant ":QuestRepository" as QuestRepo
participant ":IQuestDifficultyResolver" as IResolver
participant ":QuestDifficultyResolver" as Resolver
participant ":IUserQuestAttemptRepository" as IAttemptRepo
participant ":UserQuestAttemptRepository" as AttemptRepo
database ":Database" as DB

Student -> UI : Click "Sync Quest Line"
activate UI

UI -> Controller : ProcessMyAcademicRecord()
activate Controller

Controller -> Med : Send(GenerateQuestLineCommand)
activate Med

Med -> Handler : Handle(command)
activate Handler

' 1. Get Context
Handler -> IProfileRepo : GetByAuthIdAsync(userId)
activate IProfileRepo
IProfileRepo -> ProfileRepo : GetByAuthIdAsync(userId)
activate ProfileRepo
' Analyzed: Matches user_profiles schema (auth_user_id is the lookup key)
ProfileRepo -> DB : SELECT * FROM user_profiles WHERE auth_user_id = @userId
activate DB
DB --> ProfileRepo : Record
deactivate DB
ProfileRepo --> IProfileRepo : UserProfile
deactivate ProfileRepo
IProfileRepo --> Handler : UserProfile (RouteId, ClassId)
deactivate IProfileRepo

Handler -> ISubjectRepo : GetSubjectsByRoute(RouteId)
activate ISubjectRepo
ISubjectRepo -> SubjectRepo : GetSubjectsByRoute(RouteId)
activate SubjectRepo
' Analyzed: Joins via curriculum_program_subjects link table
SubjectRepo -> DB : SELECT s.* FROM subjects s \nJOIN curriculum_program_subjects cps ON s.id = cps.subject_id \nWHERE cps.program_id = @RouteId
activate DB
DB --> SubjectRepo : Records
deactivate DB
SubjectRepo --> ISubjectRepo : List<Subject>
deactivate SubjectRepo
ISubjectRepo --> Handler : List<Subject>
deactivate ISubjectRepo

Handler -> IGradeRepo : FindAsync(userId)
activate IGradeRepo
IGradeRepo -> GradeRepo : FindAsync(userId)
activate GradeRepo
' Analyzed: Matches student_semester_subjects table
GradeRepo -> DB : SELECT * FROM student_semester_subjects \nWHERE auth_user_id = @userId
activate DB
DB --> GradeRepo : Records
deactivate DB
GradeRepo --> IGradeRepo : List<StudentSemesterSubject>
deactivate GradeRepo
IGradeRepo --> Handler : List<StudentSemesterSubject>
deactivate IGradeRepo

' 2. Process Subjects
loop For Each Subject
    Handler -> IQuestRepo : FindAsync(SubjectId)
    activate IQuestRepo
    IQuestRepo -> QuestRepo : FindAsync(SubjectId)
    activate QuestRepo
    ' Analyzed: Matches quests table FK subject_id
    QuestRepo -> DB : SELECT * FROM quests WHERE subject_id = @SubjectId
    activate DB
    DB --> QuestRepo : Record
    deactivate DB
    QuestRepo --> IQuestRepo : MasterQuest
    deactivate QuestRepo
    IQuestRepo --> Handler : MasterQuest
    deactivate IQuestRepo

    alt Master Quest Found
        Handler -> IResolver : ResolveDifficulty(GradeRecord)
        activate IResolver
        IResolver -> Resolver : ResolveDifficulty(GradeRecord)
        activate Resolver
        Resolver --> IResolver : DifficultyInfo (e.g., "Challenging")
        deactivate Resolver
        IResolver --> Handler : DifficultyInfo
        deactivate IResolver

        Handler -> IAttemptRepo : FirstOrDefaultAsync(UserId, QuestId)
        activate IAttemptRepo
        IAttemptRepo -> AttemptRepo : FirstOrDefaultAsync(UserId, QuestId)
        activate AttemptRepo
        ' Analyzed: Matches user_quest_attempts composite lookup
        AttemptRepo -> DB : SELECT * FROM user_quest_attempts \nWHERE auth_user_id = @UserId AND quest_id = @QuestId
        activate DB
        DB --> AttemptRepo : ExistingAttempt?
        deactivate DB
        AttemptRepo --> IAttemptRepo : ExistingAttempt?
        deactivate AttemptRepo
        IAttemptRepo --> Handler : ExistingAttempt?
        deactivate IAttemptRepo
        
        alt Attempt Not Exists
            Handler -> IAttemptRepo : AddAsync(NewAttempt)
            activate IAttemptRepo
            IAttemptRepo -> AttemptRepo : AddAsync(NewAttempt)
            activate AttemptRepo
            ' Analyzed: Inserts into user_quest_attempts (status='InProgress', assigned_difficulty=...)
            AttemptRepo -> DB : INSERT INTO user_quest_attempts...
            activate DB
            DB --> AttemptRepo : Success
            deactivate DB
            AttemptRepo --> IAttemptRepo : Success
            deactivate AttemptRepo
            IAttemptRepo --> Handler : Success
            deactivate IAttemptRepo
        else Attempt Exists
            Handler -> IAttemptRepo : UpdateAsync(ExistingAttempt)
            activate IAttemptRepo
            IAttemptRepo -> AttemptRepo : UpdateAsync(ExistingAttempt)
            activate AttemptRepo
            ' Analyzed: Updates existing record
            AttemptRepo -> DB : UPDATE user_quest_attempts SET...
            activate DB
            DB --> AttemptRepo : Success
            deactivate DB
            AttemptRepo --> IAttemptRepo : Success
            deactivate AttemptRepo
            IAttemptRepo --> Handler : Success
            deactivate IAttemptRepo
        end
    end
end

Handler --> Med : Response
deactivate Handler

Med --> Controller : Success
deactivate Med

Controller --> UI : 200 OK (Quest Line Updated)
deactivate Controller

UI -> UI : Animate New Quests
UI --> Student : Show Updated Map
deactivate UI
@enduml