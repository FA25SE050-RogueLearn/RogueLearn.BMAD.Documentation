@startuml
actor Admin
participant AdminManagementUI as UI
participant ":QuestStepContentEditor\nController" as Controller
participant ":IMediator" as Med
participant ":GetQuestStepContent\nQueryHandler" as Handler
participant ":IQuestStepRepository" as IRepo
participant ":QuestStepRepository" as Repo
database ":Database" as DB

Admin -> UI : Select Quest Step to Edit
activate UI

UI -> Controller : GET /api/admin/quest-steps/{id}/content
activate Controller

Controller -> Med : Send(GetQuestStepContentQuery)
activate Med

Med -> Handler : Handle(query)
activate Handler

' 1. Fetch Quest Step
Handler -> IRepo : GetByIdAsync(QuestStepId)
activate IRepo
IRepo -> Repo : GetByIdAsync(QuestStepId)
activate Repo
Repo -> DB : SELECT * FROM quest_steps...
activate DB
DB --> Repo : QuestStep (with JSONB content)
deactivate DB
Repo --> IRepo : QuestStep
deactivate Repo
IRepo --> Handler : QuestStep
deactivate IRepo

alt Not Found
    Handler --> Med : Throw NotFoundException
    deactivate Handler
    Med --> Controller : 404 Not Found
    deactivate Med
    Controller --> UI : 404 Not Found
    UI --> Admin : Show Error Message
else Found
    ' 2. Parse Content
    activate Handler
    Handler -> Handler : Deserialize Content JSON
    note right
        Uses Newtonsoft.Json to parse
        nested JObject/JArray structure
    end note
    
    Handler -> Handler : Map to QuestStepContentResponse
    
    Handler --> Med : QuestStepContentResponse
    deactivate Handler
    
    Med --> Controller : Response
    deactivate Med
    
    Controller --> UI : 200 OK (Content DTO)
    deactivate Controller
    
    UI -> UI : Populate Editor Fields
    UI --> Admin : Display Content Editor
end
deactivate UI
@enduml