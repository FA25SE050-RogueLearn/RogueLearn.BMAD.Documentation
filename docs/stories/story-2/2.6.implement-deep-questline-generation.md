// RougeLearn.BMAD.Documentation/docs/stories/story-2/2.6.implement-deep-questline-generation.md
# **Story 2.6: Implement Deep QuestLine Generation Logic**

## Status

Approved

## Ownership

*   **Primary Owner:** An (Backend)
*   **Supporting:** Minh Anh (Backend)
*   **Rationale:** This is the logical continuation of Story 2.2 and is central to the `QuestService`'s core responsibility. It requires deep implementation within the `QuestService`'s domain.

## Story

**As a** Developer,
**I want** to enhance the QuestLine generation logic,
**so that** it transforms a fetched curriculum blueprint into a fully structured, multi-layered learning path, complete with chapters, granular steps, and skill associations.

## Acceptance Criteria

1.  When the `GenerateQuestLineFromCurriculumCommand` is executed, it must group the fetched subjects by their `semester` (term number) and create a `QuestChapter` for each distinct semester, ordered sequentially.
2.  For each `Quest` (Subject), the handler must be able to process detailed syllabus information (e.g., from a future API call or mocked data) to create individual, ordered `QuestSteps`.
3.  The generation logic must associate each created `Quest` with relevant skills by querying the `UserService` for the system-wide **Skill Catalog** and mapping subject content to skill tags in the `quests.skill_tags` array.
4.  The handler must parse the `prerequisites` from the curriculum data to create `QuestDependency` records, ensuring the correct academic sequence is maintained.
5.  All newly created entities (`QuestChapter`, `QuestStep`, `QuestDependency`) must be correctly persisted to the `QuestsService` database.
6.  The entire generation process must be idempotent; if the same `curriculumVersionId` is processed again, it should update the existing `LearningPath` and its children rather than creating duplicates.

## Tasks / Subtasks

- [ ] **Task 1: Implement Quest Chapter Generation** (AC: #1)
    - [ ] Modify the `GenerateQuestLineFromCurriculumCommandHandler`.
    - [ ] After creating the main `LearningPath`, group the `SubjectDto` list by `Semester`.
    - [ ] For each semester group, create a `QuestChapter` entity, setting its `Title` (e.g., "Semester 1"), `Sequence`, and linking it to the `LearningPathId`.
    - [ ] Persist the `QuestChapter` entities to the database.
- [ ] **Task 2: Implement QuestStep Generation from Syllabus** (AC: #2)
    - [ ] Create a placeholder or mock implementation for fetching detailed syllabus data for a subject.
    - [ ] Inside the loop that creates `Quests`, add logic to iterate over the syllabus sessions for that subject.
    - [ ] For each session, create a `QuestStep` entity with a `Title`, `Description`, `StepNumber`, and link it to the parent `QuestId`.
    - [ ] Persist the `QuestStep` entities.
- [ ] **Task 3: Implement Skill Association** (AC: #3)
    - [ ] Enhance the `IUserServiceApiClient` interface with a method to fetch the `Skill Catalog` (e.g., `GetSkillsAsync()`).
    - [ ] In the `GenerateQuestLineFromCurriculumCommandHandler`, call this new method to get a list of all available skills.
    - [ ] Implement a basic mapping logic (e.g., based on keywords in the subject name) to associate `Quests` with `skill_tags`.
- [ ] **Task 4: Implement Quest Dependency Creation** (AC: #4)
    - [ ] Within the subject processing loop, parse the `Prerequisites` string for each `SubjectDto`.
    - [ ] Create a lookup to find the `QuestId` of the prerequisite subject.
    - [ ] If found, create and persist a `QuestDependency` record linking the current quest to its prerequisite.
- [ ] **Task 5: Ensure Idempotency** (AC: #6)
    - [ ] Before creating a new `LearningPath`, check if one already exists for the given `curriculumVersionId`.
    - [ ] If it exists, implement an "update-or-create" logic for all child entities (`QuestChapters`, `Quests`, etc.) to prevent creating duplicates on subsequent runs.
- [ ] **Task 6: Write Integration Tests**
    - [ ] Write a comprehensive integration test for the `GenerateQuestLineFromCurriculumCommandHandler`.
    - [ ] The test should use a mock `IUserServiceApiClient` to provide a sample curriculum.
    - [ ] Verify that the correct number of `LearningPath`, `QuestChapter`, `Quest`, and `QuestStep` entities are created.
    - [ ] Verify that `QuestDependency` records are correctly established based on the mock data.

## Dev Notes

### **Architectural Guidance**
*   This story deepens the implementation within the **`QuestService`**. It requires extending the communication with the `UserService` to fetch not only the curriculum but also the `Skill Catalog`.
*   **Idempotency** is a key non-functional requirement. The generation process might be re-run by an admin. The system must handle this gracefully by updating existing records rather than creating duplicates. The combination of `curriculumVersionId` on the `LearningPath` should be the unique key for this check.

### **Data Flow and Dependencies**
1.  **Input:** `curriculumVersionId`.
2.  **External Calls (to `UserService`):**
    *   `GET /api/admin/curriculum/versions/{id}/for-generation` (already planned).
    *   `GET /api/internal/skills` (a new endpoint will be needed on the `UserService` to expose the skill catalog).
3.  **Processing:** The handler will now orchestrate a more complex transformation, creating a hierarchical structure of `LearningPath` -> `QuestChapter` -> `Quest` -> `QuestStep`.
4.  **Output:** A fully populated, interconnected set of gamified learning entities in the `QuestService` database.

## Change Log

| Date | Version | Description | Author |
| :--- | :--- | :--- | :--- |
| [Current Date] | 1.0 | Initial story draft to implement deep quest generation logic. | BMad Orchestrator |